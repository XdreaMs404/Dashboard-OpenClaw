# S016 - Indexeur tableaux markdown et schéma (FR-024/FR-025)

## Epic
E02

## Handoff courant
H13 PM → DEV (scope strict S016)

## User story
En tant qu’orchestrateur BMAD,
je veux indexer de manière fiable les tableaux markdown des artefacts conformes,
afin de permettre des requêtes ciblées sur les données tabulaires et préparer la recherche full-text filtrée.

## Dépendances
- **S013** (`extractArtifactSectionsForNavigation`) : extraction H2/H3 + artefacts éligibles (`tableIndexEligible`).
- **S012** (`validateArtifactMetadataCompliance`) : garde-fou metadata obligatoire.
- **Planning E02-S04** (`_bmad-output/planning-artifacts/epics.md`) : source de vérité story-level.
- **PRD** (`_bmad-output/planning-artifacts/prd.md`) : FR-024, FR-025, AC-024A/B, AC-025A/B, NFR-012, NFR-016.
- **Architecture** (`_bmad-output/planning-artifacts/architecture.md`) :
  - endpoint cible `GET /api/v1/artifacts/{artifactId}/tables`,
  - projection cible `projection.artifact.tables`,
  - événement cible `artifact.table.indexed`,
  - index data cible `IDX-14 ArtifactTableIndex(artifact_id)`.

## Traçabilité
- **FR-024** : indexer les tableaux markdown pour requêtes ciblées.
- **FR-025 (préparation)** : exposer une structure d’index exploitable par la recherche full-text story suivante (S015).
- **AC PRD** : AC-024A, AC-024B, AC-025A, AC-025B.
- **NFR-012** : 0 perte silencieuse (aucun artefact/table ignoré sans diagnostic explicite).
- **NFR-016** : logique de robustesse bornée (erreurs explicites, retries bornés, compatibilité DLQ côté pipeline).
- **Contraintes UX (H06)** : diagnostics explicites/actionnables + états d’interface complets.
- **Risques couverts** : T08, P02.

## Critères d'acceptation (mesurables)
- [x] **AC-01 — Indexation nominale des tableaux markdown**
      Pour un lot markdown conforme et éligible, `indexArtifactMarkdownTables` retourne :
  - `allowed: true`
  - `reasonCode: "OK"`
  - `diagnostics.indexedCount = diagnostics.requestedCount`
  - `indexedArtifacts[*].tables` non vide avec `rowCount` et `columnCount` > 0.

- [x] **AC-02 — Schéma de table stable et déterministe**
      Chaque table indexée contient :
  - `tableId` déterministe
  - `sectionHeadingId` et `sectionAnchor` de rattachement
  - `headers[]`, `rows[][]`, `rowCount`, `columnCount`
  - `schemaVersion` et `extractedAt`
      sans variation non déterministe entre deux runs identiques.

- [x] **AC-03 — Détection absence de tableaux**
      Si un artefact markdown éligible ne contient aucun tableau exploitable :
  - `allowed: false`
  - `reasonCode: "ARTIFACT_TABLES_MISSING"`
  - `nonIndexedArtifacts[*].tableErrors` explicite le diagnostic
  - `correctiveActions` contient `ADD_MARKDOWN_TABLES`.

- [x] **AC-04 — Garde-fous S012/S013 respectés**
      Si metadata manquante/invalide ou sections indisponibles :
  - blocage explicite de l’artefact concerné
  - propagation cohérente de `ARTIFACT_METADATA_MISSING | ARTIFACT_METADATA_INVALID | ARTIFACT_SECTIONS_MISSING`
  - aucun contournement silencieux.

- [x] **AC-05 — Blocage hors allowlist**
      Si un artefact sort des racines autorisées :
  - `reasonCode: "ARTIFACT_PATH_NOT_ALLOWED"`
  - aucune exception non contrôlée.

- [x] **AC-06 — Blocage type non supporté pour indexation tables**
      Si une extension hors `.md|.markdown` est soumise :
  - `reasonCode: "UNSUPPORTED_ARTIFACT_TYPE"`
  - diagnostic explicite par artefact.

- [x] **AC-07 — Parse markdown robuste**
      Frontmatter/markdown invalide :
  - `reasonCode: "ARTIFACT_PARSE_FAILED"` localisé par artefact
  - aucun crash global du lot.

- [x] **AC-08 — Contrat de sortie stable + préparation FR-025**
      La fonction retourne systématiquement :
      `{ allowed, reasonCode, reason, diagnostics, indexedArtifacts, nonIndexedArtifacts, correctiveActions }`
      avec :
  - `reasonCode` dans
    `OK | ARTIFACT_PATH_NOT_ALLOWED | UNSUPPORTED_ARTIFACT_TYPE | ARTIFACT_READ_FAILED | ARTIFACT_PARSE_FAILED | ARTIFACT_METADATA_MISSING | ARTIFACT_METADATA_INVALID | ARTIFACT_SECTIONS_MISSING | ARTIFACT_TABLES_MISSING | INVALID_TABLE_INDEX_INPUT`
  - `diagnostics` contient au minimum
    `requestedCount`, `processedCount`, `indexedCount`, `nonIndexedCount`, `tableCount`, `emptyTableCount`, `allowlistRoots`, `durationMs`, `p95IndexMs`
  - `indexedArtifacts[*].searchIndexEligible === true` (préparation S015).

- [x] **AC-09 — UI e2e démonstrateur minimal**
      Couvrir `empty`, `loading`, `success`, `error` avec affichage explicite :
  - `reasonCode`
  - `reason`
  - compteurs (`indexedCount`, `nonIndexedCount`, `tableCount`)
  - `correctiveActions`.

- [x] **AC-10 — Seuil qualité/performance module**
  - Couverture module S016 >= **95% lignes** et **95% branches**.
  - Benchmark corpus 500 docs :
    - `p95IndexMs <= 2000`
    - durée lot complet `< 60000 ms`
  - Conservation des comptes: `indexedCount + nonIndexedCount = requestedCount`.

## Cas de test obligatoires
### Fonctionnels
- [x] Cas nominal: tables markdown valides -> `OK`.
- [x] Cas schéma: validation `headers/rows/rowCount/columnCount` cohérente.
- [x] Cas sans tableau -> `ARTIFACT_TABLES_MISSING`.
- [x] Cas metadata invalide/manquante (hérité S012) -> blocage explicite.
- [x] Cas sections absentes (hérité S013) -> `ARTIFACT_SECTIONS_MISSING`.
- [x] Cas hors allowlist -> `ARTIFACT_PATH_NOT_ALLOWED`.
- [x] Cas extension invalide (`.yaml`, `.json`) -> `UNSUPPORTED_ARTIFACT_TYPE`.
- [x] Cas parse invalide -> `ARTIFACT_PARSE_FAILED`.
- [x] Cas source absente -> `INVALID_TABLE_INDEX_INPUT`.
- [x] Cas UI e2e: parcours `empty -> loading -> error/success`.

### Non-régression
- [x] `ingestBmadArtifacts` (S011) conserve son contrat public et ses reason codes.
- [x] `validateArtifactMetadataCompliance` (S012) conserve son contrat public et ses reason codes.
- [x] `extractArtifactSectionsForNavigation` (S013) conserve son contrat public et ses reason codes.
- [x] Les suites S001..S013 restent vertes.
- [x] Aucun changement de comportement non requis hors scope S016.

### Sécurité / robustesse
- [x] Validation stricte des entrées (allowlist, chemins, payload, markdown tables).
- [x] Refus déterministe des chemins hors racines autorisées.
- [x] Aucune exécution shell dans S016.
- [x] Aucune mutation observable des entrées.

## Scope DEV strict S016
### Autorisé
1. Implémenter `indexArtifactMarkdownTables(input, options?)` dans `app/src/artifact-table-indexer.js`.
2. Exporter S016 dans `app/src/index.js` (export S016 uniquement).
3. Ajouter/adapter les tests S016:
   - `app/tests/unit/artifact-table-indexer.test.js`
   - `app/tests/edge/artifact-table-indexer.edge.test.js`
   - `app/tests/e2e/artifact-table-indexer.spec.js`
4. Ajuster **minimalement** `app/src/artifact-section-extractor.js` uniquement si nécessaire au partage utilitaire, sans changement de comportement S013.
5. Mettre à jour la story S016 + handoffs DEV (`S016-dev-to-uxqa.md`, `S016-dev-to-tea.md`) avec preuves d’exécution.

### Interdit (hors-scope)
- Toute évolution hors FR-024/FR-025 / S016.
- Toute implémentation complète de la recherche full-text (scope S015).
- Toute modification fonctionnelle des stories S001..S013 non strictement nécessaire à l’intégration S016.
- Tout refactor transverse non requis par les AC S016.
- Toute exécution shell depuis les modules S016.

## Contraintes
- Validation metadata S012 et extraction sections S013 obligatoires avant indexation de tables.
- Types d’artefacts supportés pour indexation tables : `.md`, `.markdown`.
- Contrat de sortie déterministe et reason codes stables.
- Aucun tableau ne doit être silencieusement ignoré (diagnostic obligatoire).
- Story non-DONE tant que **G4-T** et **G4-UX** ne sont pas tous deux PASS.

## Implémentation
### Réalisé (DEV)
1. Création de `app/src/artifact-table-indexer.js` avec API `indexArtifactMarkdownTables(input, options?)`.
2. Résolution des sources conforme PM:
   - `artifactDocuments` prioritaire,
   - sinon `artifactPaths` + `options.documentReader`,
   - sinon `INVALID_TABLE_INDEX_INPUT`.
3. Intégration explicite des garde-fous S012/S013 via appel `extractArtifactSectionsForNavigation` (allowlist + type + parse + metadata + sections).
4. Indexation de tableaux markdown avec schéma stable:
   - `tableId` déterministe,
   - `sectionHeadingId`/`sectionAnchor`,
   - `headers`, `rows`, `rowCount`, `columnCount`,
   - `schemaVersion`, `extractedAt`.
5. Gestion explicite `ARTIFACT_TABLES_MISSING` + `tableErrors`.
6. Contrat de sortie stable livré:
   `{ allowed, reasonCode, reason, diagnostics, indexedArtifacts, nonIndexedArtifacts, correctiveActions }`.
7. Préparation FR-025 intégrée: `indexedArtifacts[*].searchIndexEligible = true`.
8. Export S016 ajouté dans `app/src/index.js` (`indexArtifactMarkdownTables`).
9. Tests S016 ajoutés/renforcés:
   - `app/tests/unit/artifact-table-indexer.test.js`
   - `app/tests/edge/artifact-table-indexer.edge.test.js`
   - `app/tests/e2e/artifact-table-indexer.spec.js`

## Review
- [x] Mapping AC → tests documenté.
- [x] Vérification explicite des seuils performance NFR-012/NFR-016.
- [x] Vérification couverture module >= 95% lignes + branches.
- [x] Résultat gates techniques publié (PASS/CONCERNS/FAIL).

### Mapping AC → tests
- AC-01/02/03/04/05/06/07/08/10: `app/tests/unit/artifact-table-indexer.test.js`, `app/tests/edge/artifact-table-indexer.edge.test.js`
- AC-09: `app/tests/e2e/artifact-table-indexer.spec.js`
- AC-10 coverage: `npm run test:coverage` (S016 `artifact-table-indexer.js` = **99.09% lines**, **96.99% branches**)
- AC-10 performance (500 docs): test unitaire dédié (`p95IndexMs <= 2000`, durée `< 60000`)
- AC-10 benchmark replay (UTC 2026-02-22T08:15:27Z): `requested=500`, `indexed=500`, `nonIndexed=0`, `tableCount=500`, `p95IndexMs=0`, `durationMs=48`

### Gates techniques (DEV)
Commande de revalidation exécutée depuis `app/` (UTC 2026-02-22T08:15:27Z):
`npm run lint && npm run typecheck && npx vitest run tests/unit tests/edge && npx playwright test tests/e2e && npm run test:coverage && npm run build && npm run security:deps` ✅

Résultats observés:
- `npm run lint` ✅
- `npm run typecheck` ✅
- `npx vitest run tests/unit tests/edge` ✅ (**28 fichiers / 346 tests passés**)
- `npx playwright test tests/e2e` ✅ (**27/27 tests passés**)
- `npm run test:coverage` ✅
  - global: **99.40% statements / 97.74% branches / 100% functions / 99.38% lines**
  - module S016 `app/src/artifact-table-indexer.js`: **99.13% statements / 96.99% branches / 100% functions / 99.09% lines**
- `npm run build` ✅
- `npm run security:deps` ✅ (`npm audit --audit-level=high`: **0 vulnérabilité**)
- Verdict technique DEV: **PASS**

## Comment tester (simple)
1. `cd /root/.openclaw/workspace/projects/dashboard-openclaw/app`
2. `npm run lint && npm run typecheck`
3. `npx vitest run tests/unit/artifact-table-indexer.test.js tests/edge/artifact-table-indexer.edge.test.js`
4. `npx playwright test tests/e2e/artifact-table-indexer.spec.js`
5. `npm run test:coverage`
6. `npm run build && npm run security:deps`

## Quality Gates obligatoires
- [x] lint
- [x] typecheck
- [x] tests unit/intégration
- [x] tests e2e
- [x] tests cas limites (edge)
- [x] coverage >= seuil
- [x] security scan dépendances
- [x] build

## Règle Story DONE
- Interdit de passer DONE si un seul gate échoue (technique OU UX).
- Audit UX obligatoire: `_bmad-output/implementation-artifacts/ux-audits/<SID>-ux-audit.json` avec verdict PASS.
- Utiliser `bash scripts/story-done-guard.sh <SID>` pour valider la fin.

## UX Gates obligatoires
- [ ] conformité design-system (tokens, spacing, typo, composants)
- [ ] accessibilité WCAG 2.2 AA (minimum)
- [ ] responsive (mobile/tablet/desktop)
- [ ] états d'interface (loading/empty/error/success)
- [ ] hiérarchie visuelle et lisibilité
- [ ] evidence UX fournie (captures/rapports)

## Status
- Dernière revalidation DEV (UTC): 2026-02-22T08:15:27Z
READY_FOR_UX_AUDIT
READY_FOR_TEA
