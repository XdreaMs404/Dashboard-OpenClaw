# S007 - Alerte de dépassement SLA de transition + plan d’action corrective

## Epic
E01

## User story
En tant qu’orchestrateur BMAD,
je veux détecter explicitement les dépassements de SLA de transition et proposer des actions correctives ordonnées,
afin de réduire le temps de résolution et d’éviter la répétition des blocages `PHASE_NOTIFICATION_SLA_EXCEEDED`.

## Dépendances
- **S002** (`validatePhaseTransition`) : source de vérité de la validation transition + SLA (`PHASE_NOTIFICATION_SLA_EXCEEDED`).
- **S006** (`recordPhaseTransitionHistory`) : source de contexte historique pour compter les récidives SLA dans une fenêtre glissante.
- **Socle S001..S006** (`app/src` + tests unit/edge/e2e) : non-régression obligatoire.

## Traçabilité
- **FR-008** : signaler les dépassements de SLA de transition et proposer un plan d’action corrective.
- **FR-007 (réutilisation)** : exploiter l’historique consultable pour détecter la récurrence des incidents SLA.
- **NFR-013** : validation correcte >= 95% (propagation déterministe des reason codes + contrat stable).
- **NFR-017** : SLA notification par défaut = 10 minutes (alignement strict S002, aucune divergence).
- **NFR-034** : diagnostics exploitables en continu pour pilotage + handoff.
- **Risques couverts** : P02, P03, P06.

## Critères d'acceptation (mesurables)
- [x] **AC-01 — Nominal sans incident SLA**
      Pour une transition valide (`reasonCode=OK` via `transitionValidation` ou `transitionInput`), `evaluatePhaseSlaAlert` retourne:
  - `allowed: true`
  - `reasonCode: "OK"`
  - `alert.active: false`
  - `correctiveActions: []`
- [x] **AC-02 — Incident SLA détecté**
      Si la transition est bloquée avec `reasonCode="PHASE_NOTIFICATION_SLA_EXCEEDED"`, la sortie propage strictement le même `reasonCode` + `reason`, avec:
  - `alert.active: true`
  - `alert.severity: "warning"`
  - `correctiveActions` ordonné: `PUBLISH_PHASE_NOTIFY`, `REVALIDATE_TRANSITION`
- [x] **AC-03 — Escalade sur récurrence**
      Si incident SLA courant **et** `recentSlaBreachCount >= escalationThreshold` dans la fenêtre `lookbackMinutes` (défaut 60 min):
  - `alert.severity = "critical"`
  - `correctiveActions` ajoute `ESCALATE_TO_PM` en 3e position
- [x] **AC-04 — Source de données flexible**
  - `transitionValidation` fourni -> utilisé tel quel (pas de recalcul)
  - sinon `transitionInput` -> délégation à S002 (`validatePhaseTransition`)
  - absence des deux -> blocage explicite `INVALID_SLA_ALERT_INPUT`
- [x] **AC-05 — Entrées invalides**
      Payload invalide (`history` non-tableau, `lookbackMinutes` invalide, `escalationThreshold < 1`) ->
  - `allowed=false`
  - `reasonCode="INVALID_SLA_ALERT_INPUT"`
  - aucune exception non contrôlée
- [x] **AC-06 — Contrat de sortie stable**
      La fonction retourne systématiquement:
  `{ allowed, reasonCode, reason, diagnostics, alert, correctiveActions }`
      avec:
  - `reasonCode` dans
    `OK | INVALID_PHASE | TRANSITION_NOT_ALLOWED | PHASE_NOTIFICATION_MISSING | PHASE_NOTIFICATION_SLA_EXCEEDED | INVALID_SLA_ALERT_INPUT`
  - `diagnostics` contenant au minimum:
    `fromPhase`, `toPhase`, `elapsedMs`, `slaMs`, `recentSlaBreachCount`, `lookbackMinutes`, `escalationThreshold`, `escalationRequired`, `sourceReasonCode`
- [x] **AC-07 — UI e2e démonstrateur minimal**
      Couvrir les états `empty`, `loading`, `success`, `error` avec affichage explicite:
  - `reasonCode`
  - `reason`
  - `severity`
  - `correctiveActions`
- [x] **AC-08 — Seuil qualité module**
      Couverture module S007 >= **95% lignes** et **95% branches**.

## Cas de test obligatoires
### Fonctionnels
- [x] Cas nominal sans incident: transition autorisée (`H04 -> H05`) -> `allowed=true`, `alert.active=false`, aucune action corrective.
- [x] Cas incident SLA: transition bloquée `PHASE_NOTIFICATION_SLA_EXCEEDED` -> propagation stricte + actions `PUBLISH_PHASE_NOTIFY`, `REVALIDATE_TRANSITION`.
- [x] Cas escalade: incident SLA courant + historique de récidive dans 60 min -> `severity=critical`, action `ESCALATE_TO_PM` ajoutée.
- [x] Cas délégation S002: sans `transitionValidation` mais avec `transitionInput`, délégation correcte à `validatePhaseTransition`.
- [x] Cas payload invalide: `history=null` ou `lookbackMinutes="abc"` ou `escalationThreshold=0` -> `INVALID_SLA_ALERT_INPUT`.
- [x] Cas UI e2e: parcours `empty -> loading -> error/success` avec rendu explicite du plan correctif.

### Non-régression
- [x] `validatePhaseTransition` (S002) conserve son contrat et ses reason codes.
- [x] `recordPhaseTransitionHistory` (S006) conserve son contrat, ses filtres et sa rétention.
- [x] `orchestratePhaseGuards` (S005) et `validatePhasePrerequisites` (S004) restent inchangés.
- [x] Les suites unit/edge/e2e existantes S001..S006 restent vertes.

### Sécurité / robustesse
- [x] Validation stricte des entrées (`transitionValidation`, `transitionInput`, `history`, `lookbackMinutes`, `escalationThreshold`).
- [x] Aucune mutation observable des objets d’entrée.
- [x] Aucune exécution shell dans S007.
- [x] Messages de blocage explicites, actionnables et exploitables côté UI.

## Scope DEV strict S007
### Autorisé
1. Implémenter `evaluatePhaseSlaAlert(input, options?)` dans `app/src/phase-sla-alert.js`.
2. Exporter S007 dans `app/src/index.js` (export S007 uniquement).
3. Ajouter/adapter les tests S007:
   - `app/tests/unit/phase-sla-alert.test.js`
   - `app/tests/edge/phase-sla-alert.edge.test.js`
   - `app/tests/e2e/phase-sla-alert.spec.js`
4. Mettre à jour la story S007 + handoffs DEV (`S007-dev-to-uxqa.md`, `S007-dev-to-tea.md`) avec preuves d’exécution.

### Interdit (hors-scope)
- Toute évolution hors FR-008 / S007.
- Toute modification métier S001..S006 non strictement nécessaire à l’intégration S007.
- Tout refactor transverse non requis par les AC S007.
- Toute exécution shell depuis le module S007.

## Contraintes
- Scope strict S007: pas de modification produit hors FR-008.
- S002 reste la source de vérité SLA (aucune logique contradictoire).
- `history` (format S006) est consommé en lecture seule pour le calcul de récurrence.
- Story non-DONE tant que **G4-T** et **G4-UX** ne sont pas tous deux PASS.

## Implémentation
### Réalisé (DEV)
1. Implémentation de `evaluatePhaseSlaAlert(input, options?)` dans `app/src/phase-sla-alert.js` avec contrat stable:
   `{ allowed, reasonCode, reason, diagnostics, alert, correctiveActions }`.
2. Résolution de la source de validation en priorité `transitionValidation`, sinon délégation `transitionInput` -> `validatePhaseTransition` (S002).
3. Validation stricte des entrées (`history`, `lookbackMinutes`, `escalationThreshold`, cohérence `transitionValidation`) avec blocage explicite `INVALID_SLA_ALERT_INPUT` sans exception non contrôlée.
4. Calcul immuable de récurrence SLA sur fenêtre glissante (`lookbackMinutes`, défaut 60) + seuil d’escalade (`escalationThreshold`, défaut 2) en lecture seule du `history` S006.
5. Génération déterministe du plan correctif ordonné:
   - `PUBLISH_PHASE_NOTIFY`
   - `REVALIDATE_TRANSITION`
   - `ESCALATE_TO_PM` (conditionnel, 3e position).
6. Export public S007 vérifié dans `app/src/index.js` (`evaluatePhaseSlaAlert`).
7. Renforcement/maintien des tests S007:
   - `app/tests/unit/phase-sla-alert.test.js`
   - `app/tests/edge/phase-sla-alert.edge.test.js`
   - `app/tests/e2e/phase-sla-alert.spec.js`
8. Démonstrateur e2e S007 validant explicitement les états UI `empty/loading/error/success`, reason codes, severity et correctiveActions + contrôle responsive sans overflow.
9. Exécution complète des gates techniques DEV (lint/typecheck/tests/e2e/coverage/build/security) = PASS.

## Review
- [x] Mapping AC → tests documenté.
- [x] Vérification explicite de la réutilisation S002 (transitionValidation injecté ou délégation validatePhaseTransition).
- [x] Vérification couverture module >= 95% lignes + branches.
- [x] Résultat gates techniques publié (PASS/CONCERNS/FAIL).

### Mapping AC → tests
- AC-01/02/03/04/05/06/08: `app/tests/unit/phase-sla-alert.test.js`, `app/tests/edge/phase-sla-alert.edge.test.js`
- AC-07: `app/tests/e2e/phase-sla-alert.spec.js`
- AC-08 (coverage >=95% lignes+branches): `npm run test:coverage` (S007 `phase-sla-alert.js` = **100% lines**, **97.05% branches**)

### Gates techniques (DEV)
Commande de revalidation exécutée depuis `app/` (UTC 2026-02-21T14:39:42Z):
`npm run lint && npm run typecheck && npx vitest run tests/unit tests/edge && npx playwright test tests/e2e && npm run test:coverage && npm run build && npm run security:deps` ✅

Résultats observés:
- `npm run lint` ✅
- `npm run typecheck` ✅
- `npx vitest run tests/unit tests/edge` ✅ (**14 fichiers / 146 tests passés**)
- `npx playwright test tests/e2e` ✅ (**13 tests passés**)
- `npm run test:coverage` ✅
  - global: **99.64% statements / 97.97% branches / 100% functions / 99.63% lines**
  - module S007 `app/src/phase-sla-alert.js`: **100% lines / 97.05% branches**
- `npm run build` ✅
- `npm run security:deps` ✅ (`npm audit --audit-level=high`: **0 vulnérabilité**)
- Verdict technique DEV: **PASS**

## Comment tester (simple)
1. `cd /root/.openclaw/workspace/projects/dashboard-openclaw/app`
2. `npm run lint && npm run typecheck`
3. `npx vitest run tests/unit/phase-sla-alert.test.js tests/edge/phase-sla-alert.edge.test.js`
4. `npx playwright test tests/e2e/phase-sla-alert.spec.js`
5. `npm run test:coverage`
6. `npm run build && npm run security:deps`

## Quality Gates obligatoires
- [x] lint
- [x] typecheck
- [x] tests unit/intégration
- [x] tests e2e
- [x] tests cas limites (edge)
- [x] coverage >= seuil
- [x] security scan dépendances
- [x] build

## Règle Story DONE
- Interdit de passer DONE si un seul gate échoue (technique OU UX).
- Audit UX obligatoire: `_bmad-output/implementation-artifacts/ux-audits/<SID>-ux-audit.json` avec verdict PASS.
- Utiliser `bash scripts/story-done-guard.sh <SID>` pour valider la fin.

## UX Gates obligatoires
- [ ] conformité design-system (tokens, spacing, typo, composants)
- [ ] accessibilité WCAG 2.2 AA (minimum)
- [ ] responsive (mobile/tablet/desktop)
- [ ] états d'interface (loading/empty/error/success)
- [ ] hiérarchie visuelle et lisibilité
- [ ] evidence UX fournie (captures/rapports)

## Status
READY_FOR_DEV
