# S010 - Détection d’anomalies de progression de phase et alertes actionnables

## Epic
E01

## Handoff courant
H13 PM → DEV (scope strict S010)

## User story
En tant qu’orchestrateur BMAD,
je veux détecter automatiquement les anomalies de progression de phase et recevoir une alerte priorisée avec actions correctives,
afin de sécuriser la continuité canonique H01→H23 et réduire les blocages récurrents avant qu’ils ne deviennent critiques.

## Dépendances
- **S002** (`validatePhaseTransition`, `BMAD_PHASE_ORDER`) : source de vérité sur l’ordre canonique et les transitions autorisées.
- **S006** (`recordPhaseTransitionHistory`) : source de vérité du format d’historique des transitions et verdicts.
- **S009** (`buildPhaseDependencyMatrix`) : source de vérité des dépendances bloquantes temps réel et de la fraîcheur (`staleness`).
- **S001..S009** (`app/src` + tests) : non-régression obligatoire.

## Traçabilité
- **FR-001** : afficher la progression de phase en respectant strictement l’ordre canonique BMAD.
- **FR-002** : empêcher toute transition non autorisée avec raison explicite.
- **FR-010 (réutilisation)** : exploiter la matrice de dépendances temps réel pour contextualiser les anomalies.
- **AC-001A / AC-002A (PRD)** : rafraîchissement visible <= 5s pour 95% des cas (via fraîcheur S009).
- **AC-001B / AC-002B (PRD)** : blocage 100% des transitions invalides avec message explicite.
- **NFR-011** : fiabilité opérationnelle >= 99.5%.
- **NFR-013** : validation correcte >= 95% (contrat stable + reason codes cohérents).
- **NFR-034** : diagnostics continus exploitables pour pilotage/handoff.
- **Risques couverts** : P01, P02, P07.

## Critères d'acceptation (mesurables)
- [x] **AC-01 — Nominal sans anomalie**
      Pour une matrice S009 nominale (`allowed=true`, `reasonCode=OK`) et une séquence canonique valide, `evaluatePhaseProgressionAlert` retourne:
  - `allowed: true`
  - `reasonCode: "OK"`
  - `alert.active: false`
  - `anomalies: []`
  - `correctiveActions: []`

- [x] **AC-02 — Propagation stricte des blocages temps réel**
      Si S009 retourne `allowed=false` avec `reasonCode` bloquant (`TRANSITION_NOT_ALLOWED | PHASE_NOTIFICATION_MISSING | PHASE_NOTIFICATION_SLA_EXCEEDED | PHASE_PREREQUISITES_MISSING | PHASE_PREREQUISITES_INCOMPLETE | INVALID_PHASE_PREREQUISITES | DEPENDENCY_STATE_STALE`), la sortie S010:
  - propage strictement le `reasonCode` + `reason`
  - maintient `allowed=false`
  - expose `alert.active=true`
  - inclut les `blockingDependencies` et l’`owner` dans les diagnostics

- [x] **AC-03 — Détection de saut de séquence canonique**
      Si `fromPhase -> toPhase` saute au moins une phase canonique (`indexDiff > 1`), la sortie retourne:
  - `allowed: false`
  - `reasonCode: "PHASE_SEQUENCE_GAP_DETECTED"`
  - `anomalies` inclut `PHASE_SEQUENCE_GAP_DETECTED`
  - `correctiveActions` inclut `REVIEW_PHASE_SEQUENCE`

- [x] **AC-04 — Détection de régression de séquence**
      Si `toPhase` est antérieure ou identique à `fromPhase` (`indexDiff <= 0`), la sortie retourne:
  - `allowed: false`
  - `reasonCode: "PHASE_SEQUENCE_REGRESSION_DETECTED"`
  - `anomalies` inclut `PHASE_SEQUENCE_REGRESSION_DETECTED`
  - `correctiveActions` inclut `ROLLBACK_TO_CANONICAL_PHASE`

- [x] **AC-05 — Récurrence de blocages (escalade)**
      Si le nombre d’entrées bloquées récentes dans `historyEntries` (format S006) atteint `escalationThreshold` (défaut **3** sur `lookbackEntries` défaut **20**):
  - `allowed: false`
  - `reasonCode: "REPEATED_BLOCKING_ANOMALY"`
  - `alert.active: true`
  - `alert.severity: "critical"`
  - `correctiveActions` inclut `ESCALATE_TO_PM`

- [x] **AC-06 — Sources de données flexibles**
  - `dependencyMatrix` fourni -> utilisé tel quel
  - sinon `dependencyMatrixInput` -> délégation à S009 (`buildPhaseDependencyMatrix`)
  - `historyEntries` est optionnel (défaut `[]`), mais s’il est fourni il doit respecter le contrat d’entrée S006
  - absence des sources obligatoires (`dependencyMatrix` et `dependencyMatrixInput`) -> `INVALID_PHASE_PROGRESSION_INPUT`

- [x] **AC-07 — Entrées invalides**
      Entrées invalides (`fromPhase/toPhase` incohérents, seuils négatifs/non entiers, payload history invalide) ->
  - `allowed=false`
  - `reasonCode="INVALID_PHASE_PROGRESSION_INPUT"`
  - aucune exception non contrôlée

- [x] **AC-08 — Contrat de sortie stable**
      La fonction retourne systématiquement:
  `{ allowed, reasonCode, reason, diagnostics, alert, anomalies, correctiveActions }`
      avec:
  - `reasonCode` dans
    `OK | INVALID_PHASE | TRANSITION_NOT_ALLOWED | PHASE_NOTIFICATION_MISSING | PHASE_NOTIFICATION_SLA_EXCEEDED | PHASE_PREREQUISITES_MISSING | PHASE_PREREQUISITES_INCOMPLETE | INVALID_PHASE_PREREQUISITES | OVERRIDE_NOT_ELIGIBLE | OVERRIDE_REQUEST_MISSING | OVERRIDE_JUSTIFICATION_REQUIRED | OVERRIDE_APPROVER_REQUIRED | OVERRIDE_APPROVER_CONFLICT | DEPENDENCY_STATE_STALE | INVALID_PHASE_DEPENDENCY_INPUT | PHASE_SEQUENCE_GAP_DETECTED | PHASE_SEQUENCE_REGRESSION_DETECTED | REPEATED_BLOCKING_ANOMALY | INVALID_PHASE_PROGRESSION_INPUT`
  - `alert.severity` dans `info | warning | critical`
  - `anomalies[*].code` dans `PHASE_SEQUENCE_GAP_DETECTED | PHASE_SEQUENCE_REGRESSION_DETECTED | REPEATED_BLOCKING_ANOMALY | DEPENDENCY_STATE_STALE`
  - `diagnostics` contient au minimum:
    `fromPhase`, `toPhase`, `owner`, `sourceReasonCode`, `historyBlockedCount`, `lookbackEntries`, `escalationThreshold`, `dependencyAgeMs`, `isStale`

- [x] **AC-09 — UI e2e démonstrateur minimal**
      Couvrir `empty`, `loading`, `success`, `error` avec affichage explicite:
  - `reasonCode`
  - `reason`
  - `alert.active` + `alert.severity`
  - `owner`
  - `anomalies`
  - `correctiveActions`

- [x] **AC-10 — Seuil qualité module**
      Couverture module S010 >= **95% lignes** et **95% branches**.

## Cas de test obligatoires
### Fonctionnels
- [x] Cas nominal: matrice S009 `OK` + séquence canonique (`H09 -> H10`) -> `allowed=true`, aucune alerte active.
- [x] Cas blocage propagé: matrice S009 bloquée `PHASE_NOTIFICATION_MISSING` -> propagation stricte du reason code + alerte active.
- [x] Cas saut de séquence: `H09 -> H11` -> `PHASE_SEQUENCE_GAP_DETECTED` + action `REVIEW_PHASE_SEQUENCE`.
- [x] Cas régression: `H10 -> H09` -> `PHASE_SEQUENCE_REGRESSION_DETECTED` + action `ROLLBACK_TO_CANONICAL_PHASE`.
- [x] Cas récurrence blocages: historique S006 avec `>= escalationThreshold` blocages récents -> `REPEATED_BLOCKING_ANOMALY`, sévérité `critical`, action `ESCALATE_TO_PM`.
- [x] Cas staleness propagé: matrice stale (`DEPENDENCY_STATE_STALE`) -> blocage + action `REFRESH_DEPENDENCY_MATRIX`.
- [x] Cas délégation S009: sans `dependencyMatrix` mais avec `dependencyMatrixInput`, délégation correcte.
- [x] Cas UI e2e: parcours `empty -> loading -> error/success` avec rendu explicite alert/anomalies/actions.

### Non-régression
- [x] `validatePhaseTransition` (S002) conserve son contrat et ses reason codes.
- [x] `recordPhaseTransitionHistory` (S006) conserve son format d’historique et ses filtres.
- [x] `buildPhaseDependencyMatrix` (S009) conserve son contrat et ses reason codes.
- [x] Les suites unit/edge/e2e existantes S001..S009 restent vertes.

### Sécurité / robustesse
- [x] Validation stricte des entrées (`phases`, seuils, history payload, contrat S009).
- [x] Aucune mutation observable des objets d’entrée.
- [x] Aucune exécution shell dans S010.
- [x] Messages d’alerte explicites, actionnables et non ambigus.

## Scope DEV strict S010
### Autorisé
1. Implémenter `evaluatePhaseProgressionAlert(input, options?)` dans `app/src/phase-progression-alert.js`.
2. Exporter S010 dans `app/src/index.js` (export S010 uniquement).
3. Ajouter/adapter les tests S010:
   - `app/tests/unit/phase-progression-alert.test.js`
   - `app/tests/edge/phase-progression-alert.edge.test.js`
   - `app/tests/e2e/phase-progression-alert.spec.js`
4. Mettre à jour la story S010 + handoffs DEV (`S010-dev-to-uxqa.md`, `S010-dev-to-tea.md`) avec preuves d’exécution.

### Interdit (hors-scope)
- Toute évolution hors FR-001/FR-002 / S010.
- Toute modification métier S001..S009 non strictement nécessaire à l’intégration S010.
- Tout refactor transverse non requis par les AC S010.
- Toute exécution shell depuis le module S010.

## Contraintes
- Scope strict S010: pas de modification produit hors story S010.
- `BMAD_PHASE_ORDER` (S002) reste la référence unique de l’ordre canonique H01→H23.
- `buildPhaseDependencyMatrix` (S009) reste la référence unique sur blocages dépendances + fraîcheur.
- Paramètres par défaut imposés: `lookbackEntries=20`, `escalationThreshold=3`.
- Story non-DONE tant que **G4-T** et **G4-UX** ne sont pas tous deux PASS.

## Implémentation
### Réalisé (DEV)
1. Création de `app/src/phase-progression-alert.js` avec API `evaluatePhaseProgressionAlert(input, options?)`.
2. Résolution des sources conforme PM:
   - `dependencyMatrix` injecté prioritaire,
   - sinon délégation `dependencyMatrixInput` → `buildPhaseDependencyMatrix` (S009), injectable via `options.dependencyMatrixBuilder`.
3. Intégration des dépendances canoniques:
   - ordre BMAD via `BMAD_PHASE_ORDER` (S002) pour détecter saut/régression,
   - format d’historique compatible S006 (`historyEntries` validé strictement).
4. Détection d’anomalies implémentée:
   - `PHASE_SEQUENCE_GAP_DETECTED`,
   - `PHASE_SEQUENCE_REGRESSION_DETECTED`,
   - `REPEATED_BLOCKING_ANOMALY` (`lookbackEntries` / `escalationThreshold`).
5. Propagation stricte des blocages S009 (dont `DEPENDENCY_STATE_STALE`) avec `owner`, `blockingDependencies` et actions correctives.
6. Contrat stable livré:
   `{ allowed, reasonCode, reason, diagnostics, alert, anomalies, correctiveActions }`.
7. Export public S010 ajouté dans `app/src/index.js` (`evaluatePhaseProgressionAlert`).
8. Ajout/renforcement des tests S010:
   - `app/tests/unit/phase-progression-alert.test.js`
   - `app/tests/edge/phase-progression-alert.edge.test.js`
   - `app/tests/e2e/phase-progression-alert.spec.js`
9. Exécution complète des gates techniques DEV = PASS.

## Review
- [x] Mapping AC → tests documenté.
- [x] Vérification explicite réutilisation S002/S006/S009.
- [x] Vérification couverture module >= 95% lignes + branches.
- [x] Résultat gates techniques publié (PASS/CONCERNS/FAIL).

### Mapping AC → tests
- AC-01/02/03/04/05/06/07/08/10: `app/tests/unit/phase-progression-alert.test.js`, `app/tests/edge/phase-progression-alert.edge.test.js`
- AC-09: `app/tests/e2e/phase-progression-alert.spec.js`
- AC-10 (coverage >=95% lignes+branches): `npm run test:coverage` (S010 `phase-progression-alert.js` = **99.60% lines**, **95.96% branches**)

### Gates techniques (DEV)
Commande de revalidation exécutée depuis `app/` (UTC 2026-02-21T18:06:26Z):
`npm run lint && npm run typecheck && npx vitest run tests/unit tests/edge && npx playwright test tests/e2e && npm run test:coverage && npm run build && npm run security:deps` ✅

Résultats observés:
- `npm run lint` ✅
- `npm run typecheck` ✅
- `npx vitest run tests/unit tests/edge` ✅ (**20 fichiers / 226 tests passés**)
- `npx playwright test tests/e2e` ✅ (**19/19 tests passés**)
- `npm run test:coverage` ✅
  - global: **99.59% statements / 97.94% branches / 100% functions / 99.58% lines**
  - module S010 `app/src/phase-progression-alert.js`: **99.60% statements / 95.96% branches / 100% functions / 99.60% lines**
- `npm run build` ✅
- `npm run security:deps` ✅ (`npm audit --audit-level=high`: **0 vulnérabilité**)
- Verdict technique DEV: **PASS**

## Comment tester (simple)
1. `cd /root/.openclaw/workspace/projects/dashboard-openclaw/app`
2. `npm run lint && npm run typecheck`
3. `npx vitest run tests/unit/phase-progression-alert.test.js tests/edge/phase-progression-alert.edge.test.js`
4. `npx playwright test tests/e2e/phase-progression-alert.spec.js`
5. `npm run test:coverage`
6. `npm run build && npm run security:deps`

## Quality Gates obligatoires
- [x] lint
- [x] typecheck
- [x] tests unit/intégration
- [x] tests e2e
- [x] tests cas limites (edge)
- [x] coverage >= seuil
- [x] security scan dépendances
- [x] build

## Règle Story DONE
- Interdit de passer DONE si un seul gate échoue (technique OU UX).
- Audit UX obligatoire: `_bmad-output/implementation-artifacts/ux-audits/<SID>-ux-audit.json` avec verdict PASS.
- Utiliser `bash scripts/story-done-guard.sh <SID>` pour valider la fin.

## UX Gates obligatoires
- [ ] conformité design-system (tokens, spacing, typo, composants)
- [ ] accessibilité WCAG 2.2 AA (minimum)
- [ ] responsive (mobile/tablet/desktop)
- [ ] états d'interface (loading/empty/error/success)
- [ ] hiérarchie visuelle et lisibilité
- [ ] evidence UX fournie (captures/rapports)

## Status
- Dernière revalidation DEV (UTC): 2026-02-21T18:07:00Z
READY_FOR_UX_AUDIT
READY_FOR_TEA
